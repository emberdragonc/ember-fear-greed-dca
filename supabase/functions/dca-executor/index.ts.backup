// Fear & Greed DCA Executor - Supabase Edge Function
// COMPLETE IMPLEMENTATION with UserOperation execution and fee collection

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { 
  createPublicClient, 
  createWalletClient, 
  http, 
  parseUnits, 
  formatUnits, 
  encodeFunctionData,
  encodeAbiParameters,
  parseAbiParameters,
  keccak256,
  erc20Abi,
  type Address,
  type Hex,
} from 'https://esm.sh/viem@2.21.45?target=deno'
import { base } from 'https://esm.sh/viem@2.21.45?target=deno/chains'
import { privateKeyToAccount } from 'https://esm.sh/viem@2.21.45?target=deno/accounts'
import { 
  createSmartAccountClient, 
  ENTRYPOINT_ADDRESS_V07,
  type SmartAccount
} from 'https://esm.sh/permissionless@0.2.21?target=deno'
import { signerToSimpleSmartAccount } from 'https://esm.sh/permissionless@0.2.21?target=deno/accounts'
import { pimlicoBundlerActions, pimlicoPaymasterActions } from 'https://esm.sh/permissionless@0.2.21?target=deno/actions/pimlico'
import { encodeNonce } from 'https://esm.sh/permissionless@0.2.21?target=deno/utils'

// ============ CONFIGURATION ============

const FG_THRESHOLDS = {
  EXTREME_FEAR_MAX: 25,
  FEAR_MAX: 45,
  NEUTRAL_MAX: 54,
  GREED_MAX: 75,
}

const ADDRESSES = {
  WETH: '0x4200000000000000000000000000000000000006' as Address,
  USDC: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' as Address,
  cbBTC: '0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf' as Address,
  UNISWAP_ROUTER: '0x6fF5693b99212Da76ad316178A184AB56D299b43' as Address,
  PERMIT2: '0x000000000022D473030F116dDEE9F6B43aC78BA3' as Address,
  DELEGATION_MANAGER: '0xdb9B1e94B5b69Df7e401DDbedE43491141047dB3' as Address,
  EMBER_STAKING: '0x434B2A0e38FB3E5D2ACFa2a7aE492C2A53E55Ec9' as Address,
  SIMPLE_ACCOUNT_FACTORY: '0x91E60e0613810449d098b0b5Ec8b51A0FE8c8985' as Address,
}

const FEE_BPS = 20
const BPS_DENOMINATOR = 10000
const MIN_DELEGATION_VALUE_USD = 10
const SLIPPAGE_SMALL_BPS = 50
const SLIPPAGE_LARGE_BPS = 30
const SLIPPAGE_THRESHOLD_USD = 100
const MIN_SWAP_AMOUNT = parseUnits('0.10', 6)
const TRADING_API = 'https://trade-api.gateway.uniswap.org/v1'
const EXPECTED_DELEGATE = '0xc472e866045d2e9ABd2F2459cE3BDB275b72C7e1'.toLowerCase()
const OPTIMAL_BATCH_SIZE = 50
const BATCH_DELAY_MS = 500

const UNISWAP_ROUTERS = [
  '0x6fF5693b99212Da76ad316178A184AB56D299b43',
  '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',
  '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B',
]

// ============ TYPES ============

interface DCADecision {
  action: 'buy' | 'sell' | 'hold'
  percentage: number
  reason: string
}

interface DelegationRecord {
  id: string
  user_address: string
  smart_account_address: string
  delegation_hash: string
  delegation_signature: string
  delegation_data: string
  max_amount_per_swap: string
  expires_at: string
  created_at: string
  target_asset?: string
}

interface ExecutionResult {
  success: boolean
  txHash: string | null
  error: string | null
  errorType: string | null
  amountIn: string
  amountOut: string
  feeCollected: string
  retryCount: number
  lastError: string | null
  walletAddress: string
}

interface WalletData {
  delegation: DelegationRecord
  smartAccountAddress: Address
  balance: bigint
  swapAmount: bigint
  swapAmountAfterFee: bigint
  fee: bigint
}

interface PreparedSwap {
  walletData: WalletData
  swapQuote: { quote: any; swap: any; timestamp: number }
  nonceKey: bigint
}

interface BatchSendResult {
  success: boolean
  userOpHash: string | null
  error: string | null
  walletAddress: string
}

// ============ ABIs ============

const delegationManagerAbi = [
  {
    name: 'redeemDelegations',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'delegations', type: 'bytes[][]' },
      { name: 'modes', type: 'uint8[]' },
      { name: 'executions', type: 'bytes[][]' },
    ],
    outputs: [],
  },
] as const

const permit2Abi = [
  {
    name: 'allowance',
    type: 'function',
    stateMutability: 'view',
    inputs: [
      { name: 'owner', type: 'address' },
      { name: 'token', type: 'address' },
      { name: 'spender', type: 'address' },
    ],
    outputs: [
      { name: 'amount', type: 'uint160' },
      { name: 'expiration', type: 'uint48' },
      { name: 'nonce', type: 'uint48' },
    ],
  },
  {
    name: 'approve',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'token', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint160' },
      { name: 'expiration', type: 'uint48' },
    ],
    outputs: [],
  },
] as const

const emberStakingAbi = [
  {
    name: 'depositRewards',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'token', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    outputs: [],
  },
] as const

// ============ HELPERS ============

function calculateDecision(fgValue: number): DCADecision {
  if (fgValue <= FG_THRESHOLDS.EXTREME_FEAR_MAX) {
    return { action: 'buy', percentage: 5, reason: 'Extreme Fear - Buy 5%' }
  }
  if (fgValue <= FG_THRESHOLDS.FEAR_MAX) {
    return { action: 'buy', percentage: 2.5, reason: 'Fear - Buy 2.5%' }
  }
  if (fgValue <= FG_THRESHOLDS.NEUTRAL_MAX) {
    return { action: 'hold', percentage: 0, reason: 'Neutral - Hold' }
  }
  if (fgValue <= FG_THRESHOLDS.GREED_MAX) {
    return { action: 'sell', percentage: 2.5, reason: 'Greed - Sell 2.5%' }
  }
  return { action: 'sell', percentage: 5, reason: 'Extreme Greed - Sell 5%' }
}

function calculateFee(amount: bigint): bigint {
  return (amount * BigInt(FEE_BPS)) / BigInt(BPS_DENOMINATOR)
}

function calculateAmountAfterFee(amount: bigint): bigint {
  return amount - calculateFee(amount)
}

function getSlippageBpsForSwap(swapValueUsd: number): number {
  return swapValueUsd < SLIPPAGE_THRESHOLD_USD ? SLIPPAGE_SMALL_BPS : SLIPPAGE_LARGE_BPS
}

function calculateMinAmountOut(expectedOutput: bigint, slippageBps: number): bigint {
  const slippageFactor = BigInt(BPS_DENOMINATOR - slippageBps)
  return (expectedOutput * slippageFactor) / BigInt(BPS_DENOMINATOR)
}

function isValidUniswapRouter(routerAddress: string): boolean {
  const normalized = routerAddress.toLowerCase()
  return UNISWAP_ROUTERS.some(r => r.toLowerCase() === normalized)
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}

async function withRetry<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelayMs: number = 1000,
  operation: string = 'operation'
): Promise<T | null> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (error) {
      const isLastAttempt = attempt === maxAttempts
      if (isLastAttempt) {
        console.error(`[${operation}] Failed after ${maxAttempts} attempts:`, error)
        return null
      }
      const delay = baseDelayMs * Math.pow(2, attempt - 1)
      console.log(`[${operation}] Attempt ${attempt} failed, retrying in ${delay}ms...`)
      await sleep(delay)
    }
  }
  return null
}

// ============ DELEGATION FRAMEWORK ============

enum ExecutionMode {
  SingleDefault = 0,
  Batch = 1,
}

function createExecution(target: Address, value: bigint, callData: Hex): Hex {
  // Encode execution as: abi.encode(address target, uint256 value, bytes callData)
  return encodeAbiParameters(
    parseAbiParameters('address, uint256, bytes'),
    [target, value, callData]
  )
}

function encodeRedeemDelegations(
  delegations: Hex[][],
  modes: number[],
  executions: Hex[][]
): Hex {
  return encodeFunctionData({
    abi: delegationManagerAbi,
    functionName: 'redeemDelegations',
    args: [delegations, modes, executions],
  })
}

function encodeDelegation(signedDelegation: any): Hex {
  // Encode delegation struct as bytes
  // struct Delegation { address delegate, address delegator, bytes32 authority, Caveat[] caveats, bytes32 salt, bytes signature }
  
  const { delegate, delegator, authority, caveats, salt, signature } = signedDelegation
  
  // Encode caveats array
  const encodedCaveats = caveats.map((caveat: any) => {
    return encodeAbiParameters(
      parseAbiParameters('address, bytes'),
      [caveat.enforcer as Address, caveat.terms as Hex]
    )
  })
  
  const caveatArrayEncoded = encodeAbiParameters(
    [{ type: 'tuple[]', components: [{ type: 'address' }, { type: 'bytes' }] }],
    [caveats.map((c: any) => [c.enforcer, c.terms])]
  )
  
  // Encode full delegation struct
  return encodeAbiParameters(
    parseAbiParameters('address, address, bytes32, tuple(address enforcer, bytes terms)[], bytes32, bytes'),
    [
      delegate as Address,
      delegator as Address,
      authority as Hex,
      caveats.map((c: any) => ({ enforcer: c.enforcer as Address, terms: c.terms as Hex })),
      salt as Hex,
      signature as Hex,
    ]
  )
}

// ============ ETH PRICE ============

let cachedEthPrice: number | null = null
let ethPriceCacheTime: number | null = null
const ETH_PRICE_CACHE_TTL_MS = 60000

async function getETHPriceFromUniswap(uniswapApiKey: string): Promise<number> {
  const now = Date.now()
  if (cachedEthPrice && ethPriceCacheTime && (now - ethPriceCacheTime) < ETH_PRICE_CACHE_TTL_MS) {
    return cachedEthPrice
  }

  try {
    const response = await fetch(`${TRADING_API}/quote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': uniswapApiKey,
      },
      body: JSON.stringify({
        swapper: '0x0000000000000000000000000000000000000000',
        tokenIn: ADDRESSES.USDC,
        tokenOut: ADDRESSES.WETH,
        tokenInChainId: 8453,
        tokenOutChainId: 8453,
        amount: '1000000',
        type: 'EXACT_INPUT',
        slippageTolerance: 0.5,
      }),
    })

    if (!response.ok) {
      throw new Error(`Quote API returned ${response.status}`)
    }

    const data = await response.json()
    const wethReceived = BigInt(data.quote?.output?.amount || '0')

    if (wethReceived === 0n) {
      throw new Error('Invalid quote response')
    }

    const ethPrice = Number(1e18) / Number(wethReceived)
    cachedEthPrice = ethPrice
    ethPriceCacheTime = now

    console.log(`[ETH Price] $${ethPrice.toFixed(2)}`)
    return ethPrice
  } catch (error) {
    console.error('[ETH Price] Failed:', error)
    if (cachedEthPrice) {
      return cachedEthPrice
    }
    cachedEthPrice = 2500
    ethPriceCacheTime = now
    return 2500
  }
}

// ============ BALANCE HELPERS ============

async function getBalance(publicClient: any, address: Address, token: 'USDC' | 'WETH'): Promise<bigint> {
  const tokenAddress = token === 'USDC' ? ADDRESSES.USDC : ADDRESSES.WETH
  return await publicClient.readContract({
    address: tokenAddress,
    abi: erc20Abi,
    functionName: 'balanceOf',
    args: [address],
  })
}

// ============ SWAP QUOTE ============

async function fetchSwapQuote(
  tokenIn: Address,
  tokenOut: Address,
  amountIn: bigint,
  swapper: Address,
  slippageBps: number,
  uniswapApiKey: string
): Promise<{ quote: any; swap: any; timestamp: number } | null> {
  const slippageTolerance = slippageBps / 100

  try {
    const quoteResponse = await fetch(`${TRADING_API}/quote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': uniswapApiKey,
      },
      body: JSON.stringify({
        swapper,
        tokenIn,
        tokenOut,
        tokenInChainId: 8453,
        tokenOutChainId: 8453,
        amount: amountIn.toString(),
        type: 'EXACT_INPUT',
        slippageTolerance,
      }),
    })

    if (!quoteResponse.ok) {
      console.error(`[Quote] API returned ${quoteResponse.status}`)
      return null
    }

    const quoteData = await quoteResponse.json()
    
    if (!quoteData.quote) {
      console.error('[Quote] Invalid response structure')
      return null
    }

    // Get swap calldata
    const { permitData, permitTransaction, ...cleanQuote } = quoteData
    
    const swapResponse = await fetch(`${TRADING_API}/swap`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': uniswapApiKey,
      },
      body: JSON.stringify(cleanQuote),
    })

    if (!swapResponse.ok) {
      console.error(`[Swap] API returned ${swapResponse.status}`)
      return null
    }

    const swapData = await swapResponse.json()

    // Validate router
    if (!isValidUniswapRouter(swapData.swap.to)) {
      console.error(`[Quote] Router whitelist rejection: ${swapData.swap.to}`)
      return null
    }

    return { 
      quote: quoteData, 
      swap: swapData.swap, 
      timestamp: Date.now() 
    }
  } catch (error) {
    console.error('[Quote] Fetch failed:', error)
    return null
  }
}

// ============ USEROP EXECUTION ============

async function buildAndSendUserOp(
  smartAccountClient: any,
  backendSmartAccount: any,
  delegation: DelegationRecord,
  swapQuote: { quote: any; swap: any },
  nonceKey: bigint
): Promise<{ userOpHash: string | null; error: string | null }> {
  try {
    const signedDelegation = typeof delegation.delegation_data === 'string'
      ? JSON.parse(delegation.delegation_data)
      : delegation.delegation_data

    if (!signedDelegation.signature) {
      throw new Error('Delegation missing signature')
    }

    // Create execution for the swap
    const execution = createExecution(
      swapQuote.swap.to as Address,
      BigInt(swapQuote.swap.value || '0'),
      swapQuote.swap.data as Hex
    )

    // Encode delegation as bytes
    const encodedDelegation = encodeDelegation(signedDelegation)

    // Build redeemDelegations calldata
    const redeemCalldata = encodeRedeemDelegations(
      [[encodedDelegation]],
      [ExecutionMode.SingleDefault],
      [[execution]]
    )

    // Prepare nonce
    const nonce = encodeNonce({ key: nonceKey, sequence: 0n })

    console.log(`[UserOp] Building for nonce key: ${nonceKey.toString()}`)

    // Send UserOperation
    const userOpHash = await smartAccountClient.sendUserOperation({
      account: backendSmartAccount,
      nonce,
      calls: [{
        to: ADDRESSES.DELEGATION_MANAGER,
        data: redeemCalldata,
        value: 0n,
      }],
    })

    console.log(`[UserOp] Submitted: ${userOpHash}`)
    return { userOpHash, error: null }
    
  } catch (error: any) {
    console.error('[UserOp] Build/send failed:', error)
    return { userOpHash: null, error: error?.message || 'Unknown error' }
  }
}

async function waitForUserOpReceipt(
  bundlerClient: any,
  userOpHash: string,
  walletAddress: string
): Promise<{ success: boolean; txHash: string | null; error: string | null }> {
  try {
    console.log(`[Receipt] Waiting for ${walletAddress.slice(0, 10)}...`)
    
    const receipt = await bundlerClient.waitForUserOperationReceipt({
      hash: userOpHash as `0x${string}`,
      timeout: 120000,
    })

    if (receipt.success) {
      console.log(`[Receipt] ✅ ${walletAddress.slice(0, 10)}: ${receipt.receipt.transactionHash}`)
      return {
        success: true,
        txHash: receipt.receipt.transactionHash,
        error: null,
      }
    } else {
      console.log(`[Receipt] ❌ ${walletAddress.slice(0, 10)}: UserOp reverted`)
      return {
        success: false,
        txHash: null,
        error: 'UserOperation reverted on-chain',
      }
    }
  } catch (error: any) {
    console.error(`[Receipt] Timeout for ${walletAddress.slice(0, 10)}:`, error)
    return {
      success: false,
      txHash: null,
      error: `Receipt timeout: ${error?.message || 'Unknown'}`,
    }
  }
}

// ============ FEE COLLECTION ============

async function collectFee(
  walletClient: any,
  publicClient: any,
  delegation: DelegationRecord,
  tokenAddress: Address,
  amount: bigint,
  backendAccount: any
): Promise<string | null> {
  if (amount === 0n) return null

  try {
    console.log(`[Fee] Collecting ${formatUnits(amount, tokenAddress === ADDRESSES.USDC ? 6 : 18)} ${tokenAddress === ADDRESSES.USDC ? 'USDC' : 'WETH'}`)

    const signedDelegation = typeof delegation.delegation_data === 'string'
      ? JSON.parse(delegation.delegation_data)
      : delegation.delegation_data

    // Transfer from smart account to backend EOA
    const transferCalldata = encodeFunctionData({
      abi: erc20Abi,
      functionName: 'transfer',
      args: [backendAccount.address, amount],
    })

    const execution = createExecution(tokenAddress, 0n, transferCalldata)
    const encodedDelegation = encodeDelegation(signedDelegation)
    
    const redeemCalldata = encodeRedeemDelegations(
      [[encodedDelegation]],
      [ExecutionMode.SingleDefault],
      [[execution]]
    )

    const transferTx = await walletClient.writeContract({
      address: ADDRESSES.DELEGATION_MANAGER,
      abi: delegationManagerAbi,
      functionName: 'redeemDelegations',
      args: [
        [[encodedDelegation]],
        [ExecutionMode.SingleDefault],
        [[execution]]
      ],
      account: backendAccount,
    })

    await publicClient.waitForTransactionReceipt({ hash: transferTx })
    console.log(`[Fee] Transferred to backend: ${transferTx}`)

    // Approve EMBER Staking
    const approveTx = await walletClient.writeContract({
      address: tokenAddress,
      abi: erc20Abi,
      functionName: 'approve',
      args: [ADDRESSES.EMBER_STAKING, amount],
      account: backendAccount,
    })

    await publicClient.waitForTransactionReceipt({ hash: approveTx })
    console.log(`[Fee] Approved EMBER Staking`)

    // Deposit to staking
    const depositTx = await walletClient.writeContract({
      address: ADDRESSES.EMBER_STAKING,
      abi: emberStakingAbi,
      functionName: 'depositRewards',
      args: [tokenAddress, amount],
      account: backendAccount,
    })

    await publicClient.waitForTransactionReceipt({ hash: depositTx })
    console.log(`[Fee] ✅ Deposited to stakers: ${depositTx}`)

    return depositTx
  } catch (error) {
    console.error('[Fee] Collection failed:', error)
    return null
  }
}

// ============ PARALLEL SWAP PROCESSING ============

async function processSwapsParallel(
  delegations: DelegationRecord[],
  decision: DCADecision,
  ethPriceUsd: number,
  clients: any,
  uniswapApiKey: string
): Promise<{ results: ExecutionResult[]; totalVolume: bigint; totalFees: bigint }> {
  const { smartAccountClient, publicClient, bundlerClient, backendSmartAccount, walletClient, backendAccount } = clients
  
  const isBuy = decision.action === 'buy'
  const tokenDecimals = isBuy ? 6 : 18
  const tokenSymbol = isBuy ? 'USDC' : 'WETH'

  console.log(`\n[Parallel] Processing ${delegations.length} wallets...`)

  // Phase 1: Prepare wallet data
  const walletDataList: WalletData[] = []
  
  for (const delegation of delegations) {
    try {
      const smartAccountAddress = delegation.smart_account_address as Address
      const balance = await getBalance(publicClient, smartAccountAddress, isBuy ? 'USDC' : 'WETH')

      if (balance < MIN_SWAP_AMOUNT) {
        console.log(`[Parallel] ${smartAccountAddress.slice(0, 10)}: Insufficient balance`)
        continue
      }

      const percentage = BigInt(Math.round(decision.percentage * 100))
      let swapAmount = (balance * percentage) / 10000n
      const maxAmount = BigInt(delegation.max_amount_per_swap)
      if (swapAmount > maxAmount) swapAmount = maxAmount

      const fee = calculateFee(swapAmount)
      const swapAmountAfterFee = swapAmount - fee

      walletDataList.push({
        delegation,
        smartAccountAddress,
        balance,
        swapAmount,
        swapAmountAfterFee,
        fee,
      })
    } catch (error) {
      console.error(`[Parallel] Error preparing wallet:`, error)
    }
  }

  console.log(`[Parallel] ${walletDataList.length} wallets ready`)

  const allResults: ExecutionResult[] = []
  let totalVolume = 0n
  let totalFees = 0n

  // Phase 2: Process in batches
  const PHASE2_TIMESTAMP = BigInt(Date.now())
  
  for (let batchIndex = 0; batchIndex < walletDataList.length; batchIndex += OPTIMAL_BATCH_SIZE) {
    const batch = walletDataList.slice(batchIndex, batchIndex + OPTIMAL_BATCH_SIZE)
    console.log(`\n[Batch ${Math.floor(batchIndex/OPTIMAL_BATCH_SIZE) + 1}] Processing ${batch.length} swaps...`)

    // Step 1: Fetch quotes in parallel
    const preparedSwaps = await Promise.all(
      batch.map(async (walletData, index) => {
        const globalIndex = batchIndex + index
        const nonceKey = PHASE2_TIMESTAMP * 1000000n + BigInt(globalIndex)
        
        const tokenIn = isBuy ? ADDRESSES.USDC : ADDRESSES.WETH
        const tokenOut = isBuy ? ADDRESSES.WETH : ADDRESSES.USDC
        
        const swapValueUsd = isBuy 
          ? Number(formatUnits(walletData.swapAmountAfterFee, 6))
          : Number(formatUnits(walletData.swapAmountAfterFee, 18)) * ethPriceUsd
        const slippageBps = getSlippageBpsForSwap(swapValueUsd)

        const quote = await withRetry(
          () => fetchSwapQuote(
            tokenIn,
            tokenOut,
            walletData.swapAmountAfterFee,
            walletData.smartAccountAddress,
            slippageBps,
            uniswapApiKey
          ),
          3,
          2000,
          'fetchQuote'
        )

        if (!quote) return null

        return { walletData, swapQuote: quote, nonceKey }
      })
    )

    const validPreparedSwaps = preparedSwaps.filter((s): s is PreparedSwap => s !== null)
    console.log(`[Batch] Quotes: ${validPreparedSwaps.length}/${batch.length}`)

    // Step 2: Send UserOps in parallel
    const userOpResults = await Promise.all(
      validPreparedSwaps.map(prepared =>
        buildAndSendUserOp(
          smartAccountClient,
          backendSmartAccount,
          prepared.walletData.delegation,
          prepared.swapQuote,
          prepared.nonceKey
        )
      )
    )

    // Step 3: Wait for receipts in parallel
    const receipts = await Promise.all(
      userOpResults.map((result, index) => {
        if (!result.userOpHash) {
          return Promise.resolve({
            success: false,
            txHash: null,
            error: result.error || 'UserOp submission failed',
          })
        }
        return waitForUserOpReceipt(
          bundlerClient,
          result.userOpHash,
          validPreparedSwaps[index].walletData.smartAccountAddress
        )
      })
    )

    // Step 4: Process results and collect fees
    for (let i = 0; i < validPreparedSwaps.length; i++) {
      const prepared = validPreparedSwaps[i]
      const receipt = receipts[i]

      const result: ExecutionResult = {
        success: receipt.success,
        txHash: receipt.txHash,
        error: receipt.error,
        errorType: receipt.success ? null : 'unknown',
        amountIn: prepared.walletData.swapAmountAfterFee.toString(),
        amountOut: prepared.swapQuote.quote.quote.output.amount,
        feeCollected: receipt.success ? prepared.walletData.fee.toString() : '0',
        retryCount: 0,
        lastError: receipt.error,
        walletAddress: prepared.walletData.smartAccountAddress,
      }

      allResults.push(result)

      if (receipt.success) {
        totalVolume += prepared.walletData.swapAmountAfterFee
        totalFees += prepared.walletData.fee

        // Collect fee in background (non-blocking)
        const tokenAddress = isBuy ? ADDRESSES.USDC : ADDRESSES.WETH
        collectFee(
          walletClient,
          publicClient,
          prepared.walletData.delegation,
          tokenAddress,
          prepared.walletData.fee,
          backendAccount
        ).catch(err => console.error('[Fee] Background collection failed:', err))
      }
    }

    // Rate limiting between batches
    if (batchIndex + OPTIMAL_BATCH_SIZE < walletDataList.length) {
      await sleep(BATCH_DELAY_MS)
    }
  }

  return { results: allResults, totalVolume, totalFees }
}

// ============ MAIN HANDLER ============

serve(async (req) => {
  try {
    // Environment variables
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const BACKEND_PRIVATE_KEY = Deno.env.get('BACKEND_PRIVATE_KEY')!
    const PIMLICO_API_KEY = Deno.env.get('PIMLICO_API_KEY')!
    const UNISWAP_API_KEY = Deno.env.get('UNISWAP_API_KEY')!
    const ALCHEMY_API_KEY = Deno.env.get('ALCHEMY_API_KEY')!

    // Initialize clients
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
    const alchemyRpc = `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`
    
    const publicClient = createPublicClient({
      chain: base,
      transport: http(alchemyRpc),
    })

    const backendAccount = privateKeyToAccount(`0x${BACKEND_PRIVATE_KEY}`)
    
    const walletClient = createWalletClient({
      account: backendAccount,
      chain: base,
      transport: http(alchemyRpc),
    })

    // Initialize smart account
    const simpleAccount = await signerToSimpleSmartAccount(publicClient, {
      signer: backendAccount,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      factoryAddress: ADDRESSES.SIMPLE_ACCOUNT_FACTORY,
    })

    const bundlerClient = createPublicClient({
      chain: base,
      transport: http(`https://api.pimlico.io/v2/base/rpc?apikey=${PIMLICO_API_KEY}`),
    }).extend(pimlicoBundlerActions(ENTRYPOINT_ADDRESS_V07))

    const pimlicoPaymaster = createPublicClient({
      chain: base,
      transport: http(`https://api.pimlico.io/v2/8453/rpc?apikey=${PIMLICO_API_KEY}`),
    }).extend(pimlicoPaymasterActions(ENTRYPOINT_ADDRESS_V07))

    const smartAccountClient = createSmartAccountClient({
      account: simpleAccount,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      chain: base,
      bundlerTransport: http(`https://api.pimlico.io/v2/base/rpc?apikey=${PIMLICO_API_KEY}`),
      middleware: {
        gasPrice: async () => {
          return await bundlerClient.getUserOperationGasPrice()
        },
        sponsorUserOperation: async ({ userOperation }) => {
          return await pimlicoPaymaster.sponsorUserOperation({ userOperation })
        },
      },
    })

    const clients = {
      smartAccountClient,
      publicClient,
      bundlerClient,
      backendSmartAccount: simpleAccount,
      walletClient,
      backendAccount,
    }

    console.log('========================================')
    console.log('  Fear & Greed DCA Executor')
    console.log('  Supabase Edge Function v2.0')
    console.log('========================================')
    console.log(`Time: ${new Date().toISOString()}`)
    console.log(`Backend EOA: ${backendAccount.address}`)
    console.log(`Backend Smart Account: ${simpleAccount.address}`)

    // Check backend balance
    const backendBalance = await publicClient.getBalance({ address: backendAccount.address })
    console.log(`Backend ETH: ${formatUnits(backendBalance, 18)} ETH`)

    if (backendBalance < parseUnits('0.001', 18)) {
      throw new Error('Backend wallet needs more ETH for gas!')
    }

    // 1. Fetch Fear & Greed
    const fgResponse = await fetch('https://api.alternative.me/fng/')
    if (!fgResponse.ok) {
      throw new Error(`F&G API returned ${fgResponse.status}`)
    }
    const fgData = await fgResponse.json()
    const fgValue = parseInt(fgData.data[0].value)
    const fgClassification = fgData.data[0].value_classification

    console.log(`\nFear & Greed: ${fgValue} (${fgClassification})`)

    // 2. Calculate decision
    const decision = calculateDecision(fgValue)
    console.log(`Decision: ${decision.reason}`)

    if (decision.action === 'hold') {
      console.log('\n✓ Market neutral - No action needed')
      
      await supabase.from('dca_daily_executions').insert({
        execution_date: new Date().toISOString().split('T')[0],
        fear_greed_index: fgValue,
        decision: decision.action,
        decision_reason: decision.reason,
        total_swaps: 0,
        successful_swaps: 0,
        total_volume_usd: '0',
        total_fees_usd: '0',
      })

      return new Response(
        JSON.stringify({ 
          success: true, 
          action: 'hold',
          fgValue,
          message: 'Market neutral - no swaps executed' 
        }),
        { headers: { 'Content-Type': 'application/json' } }
      )
    }

    // 3. Get active delegations
    const { data: delegations, error: delegationsError } = await supabase
      .from('delegations')
      .select('*')
      .eq('is_active', true)

    if (delegationsError) {
      throw new Error(`Failed to fetch delegations: ${delegationsError.message}`)
    }

    console.log(`\nActive delegations: ${delegations?.length || 0}`)

    if (!delegations || delegations.length === 0) {
      return new Response(
        JSON.stringify({ success: true, action: decision.action, swaps: 0 }),
        { headers: { 'Content-Type': 'application/json' } }
      )
    }

    // 4. Filter valid delegations
    const validDelegations = delegations.filter(d => {
      const delegationData = typeof d.delegation_data === 'string' 
        ? JSON.parse(d.delegation_data) 
        : d.delegation_data
      const delegate = delegationData?.delegate
      
      if (!delegate || delegate.toLowerCase() !== EXPECTED_DELEGATE) {
        return false
      }
      
      if (new Date(d.expires_at) < new Date()) {
        return false
      }
      
      return true
    })

    console.log(`Valid delegations: ${validDelegations.length}`)

    if (validDelegations.length === 0) {
      return new Response(
        JSON.stringify({ success: true, action: decision.action, swaps: 0 }),
        { headers: { 'Content-Type': 'application/json' } }
      )
    }

    // 5. Get ETH price
    const ethPriceUsd = await getETHPriceFromUniswap(UNISWAP_API_KEY)

    // 6. Process swaps in parallel
    const { results, totalVolume, totalFees } = await processSwapsParallel(
      validDelegations,
      decision,
      ethPriceUsd,
      clients,
      UNISWAP_API_KEY
    )

    const successCount = results.filter(r => r.success).length

    // 7. Log individual executions
    for (const result of results) {
      await supabase.from('dca_executions').insert({
        delegation_id: validDelegations.find(d => d.smart_account_address === result.walletAddress)?.id,
        user_address: validDelegations.find(d => d.smart_account_address === result.walletAddress)?.user_address,
        fear_greed_index: fgValue,
        decision: decision.action,
        success: result.success,
        tx_hash: result.txHash,
        amount_in: result.amountIn,
        amount_out: result.amountOut,
        fee_collected: result.feeCollected,
        error: result.error,
        error_type: result.errorType,
      })
    }

    // 8. Log daily summary
    await supabase.from('dca_daily_executions').insert({
      execution_date: new Date().toISOString().split('T')[0],
      fear_greed_index: fgValue,
      decision: decision.action,
      decision_reason: decision.reason,
      total_swaps: validDelegations.length,
      successful_swaps: successCount,
      total_volume_usd: formatUnits(totalVolume, 6),
      total_fees_usd: formatUnits(totalFees, 6),
    })

    console.log('\n========================================')
    console.log('  Execution Summary')
    console.log('========================================')
    console.log(`Processed: ${validDelegations.length}`)
    console.log(`Successful: ${successCount}`)
    console.log(`Total Volume: ${formatUnits(totalVolume, 6)} USD`)
    console.log(`Total Fees: ${formatUnits(totalFees, 6)} USD`)
    console.log('========================================\n')

    return new Response(
      JSON.stringify({ 
        success: true, 
        action: decision.action,
        fgValue,
        delegations: validDelegations.length,
        successfulSwaps: successCount,
        totalVolume: formatUnits(totalVolume, 6),
        totalFees: formatUnits(totalFees, 6),
      }),
      { headers: { 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Fatal error:', error)
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
